学习笔记

## 哈希表、映射、集合

哈希表在JS中对应的是Object（map）时间复杂度为无论好坏都为O(1)~O(n)，空间复杂度始终为O(n)，映射也是对应的map，集合set

前两种数据结构都是键值对（key-value），set中存储的单个元素不重复，在java语言中由于哈希碰撞可能会使哈希表退化成链表，但是在js中链表是使用Object构建的

## 树、二叉树、二叉搜索树

常用操作：前/中/后/层序遍历（递归/迭代），深度优先遍历，广度优先遍历。

树的定义总是以递归的形式出现，二叉搜索树也不例外，它的递归定义如下：

1. 是一棵空树
2. 是一棵由根结点、左子树、右子树组成的树，同时左子树和右子树都是二叉搜索树，且**左子树**上所有结点的数据域都**小于等于**根结点的数据域，**右子树**上所有结点的数据域都**大于等于**根结点的数据域

满足以上两个条件之一的二叉树，就是二叉搜索树。

从这个定义我们可以看出，二叉搜索树强调的是**数据域的有序性**。也就是说，二叉搜索树上的每一棵子树，都应该满足 `左孩子 <= 根结点 <= 右孩子` 这样的大小关系。

## 堆和二叉堆、图

- 堆是一种特殊的完全二叉树。

> 完全二叉树：每层节点都完全填满

- 图是网络结构的抽象模型，是一组由边连接的节点。
- 图可以表示任何二元关系，比如道路、航班......

地铁站点就是节点，连接两个节点的连线就是边，组成的网络结构的抽象模型就是图。

> 二元关系：一个图中可能存在多个节点，但是两个节点之间只能用一条边相连，无论多么复杂的图都是两两节点之间相连组成的。

![image.png](https://cdn.nlark.com/yuque/0/2020/png/1499946/1600791391657-22c6344f-90f6-4525-ae5d-53e065b31b0b.png)![image.png](https://cdn.nlark.com/yuque/0/2020/png/1499946/1600937226833-0db2374c-ff7b-431f-abce-8107351c4f24.png)

- JS中没有图这个数据结构，但是可以用Object和Array构建图。
- 图的表示法：邻接矩阵、邻接表、关联矩阵......



![image.png](https://cdn.nlark.com/yuque/0/2020/png/1499946/1600938487801-e2b90262-be49-4260-ac9a-6582a251c337.png)

在js中可以使用二维数组来表示左边的这个图，把两个节点交叉的位置使用1表示。

![image.png](https://cdn.nlark.com/yuque/0/2020/png/1499946/1600939063160-a2cb72a3-c22f-4c0c-9392-70c66d97d6c7.png)

使用对象来构建一个图：键key为各个节点，各个节点key的值都是一个数组，数组的值就是这个节点可以到的节点的值。

下面的小节均使用此数据：

```
const graph = {
  0: [1, 2],
  1: [2],
  2: [0, 3],
  3: [3]
};

module.exports = graph;
```

### 图的常用操作

- 深度优先遍历
- 广度优先遍历

### 什么是深度/广度优先遍历

和树的dfs以及bfs基本相同。

深度优先遍历：尽可能深的搜索图的分支。

广度优先遍历：先访问离根节点最近的节点。

### 深度优先遍历算法口诀

- 访问根节点。
- 对根节点的没访问过的相邻节点（限制条件）挨个进行深度优先遍历。

如果没有将已访问过的节点标记，那么两个互相有关联的节点就会使得算法进入无限循环。

 ![image.png](https://cdn.nlark.com/yuque/0/2020/png/1499946/1600941456945-728f033e-ed31-4393-a758-13f39456d082.png)

下图为标记过以访问节点后的图

![image.png](https://cdn.nlark.com/yuque/0/2020/png/1499946/1600942731169-124988e4-7789-4d1f-b86e-602fecb6ce95.png)

```
const graph = require("./graph");

const visited = new Set();
const dfs = (n) => {
  console.log(n);
  visited.add(n);
  graph[n].forEach((c) => {
    if (!visited.has(c)) {
      dfs(c);
    }
  });
};

dfs(2);
```

### 广度优先遍历算法口诀

- 新建一个队列，把根节点入队。
- 把队头出列并访问。
- 把队头的没访问过的相邻节点入队。
- 重复第二、三步，直到队列为空。

```
const graph = require("./graph");

const visited = new Set();
visited.add(2);//为防止起始节点不在队列中
const q = [2];
while (q.length) {
  const n = q.shift(); //出队
  console.log(n);
  graph[n].forEach((c) => {
    if (!visited.has(c)) {
      q.push(c);
      visited.add(n); //一旦入队就认为此节点已访问
    }
  });
}
```